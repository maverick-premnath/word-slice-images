<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>WordSlice Phonetic Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* A more kid-friendly font, falling back to sans-serif */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Base screen class */
        .screen {
            display: none; /* Hidden by default, JS will manage visibility */
            width: 100%;
            min-height: 100vh;
            overflow: hidden;
        }

        /* --- Screen 1: Home --- */
        #screen-home {
            /* Colorful gradient background */
            background: linear-gradient(135deg, #60a5fa, #f472b6, #fbbf24);
        }

        /* Floating emoji animation */
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(15deg); }
        }

        .floating-emoji {
            position: absolute;
            font-size: 3rem;
            opacity: 0.7;
            animation: float 6s ease-in-out infinite;
            z-index: 1;
        }

        /* --- Screen 3: Game --- */

        /* Style for the draggable slices */
        .word-slice {
            /* ADDED: A small delay to allow the touch-start to register */
            transition: all 0.2s ease-in-out;

            /* KEEP: For mobile drag/drop to work */
            touch-action: none;

            /* KEEP: For image slicing */
            background-size: 0% 0%;
            background-repeat: no-repeat;

            /* ADDED: Necessary for touch-based hardware acceleration */
            will-change: transform;
            cursor: grab;

            /* ADDED: Must be relative to position the speaker button inside it */
            position: relative;
        }

        /* FIXED: Speaker button positioning */
        .phonetic-speaker {
            position: absolute;
            bottom: 5px; /* Adjust vertical position */
            left: 50%;
            /* Use translate to center regardless of button width, and use 3D for hardware acceleration */
            transform: translateX(-50%) translateZ(0);

            /* Ensure the speaker button doesn't start a drag action */
            touch-action: manipulation;
        }

        /* Style for when a slice is being dragged (desktop/mobile) */
        .dragging {
            opacity: 0.75; /* Slightly less opaque for better visual feedback */
            /* Using translate3d instead of transform: scale() for smoother dragging, and to activate hardware acceleration */
            transform: scale(1.1) translateZ(0);
            cursor: grabbing;
        }

        /* NEW: Class for the touch-drag state (mobile only) */
        .touch-dragging {
            /* Override for mobile to be controlled by JS 'transform: translate3d' */
            position: fixed !important;
            z-index: 2000;
            cursor: grabbing;
        }


        /* Style for the drop zones */
        .drop-zone {
            transition: all 0.2s ease-in-out;
            background-color: rgba(255, 255, 255, 0.3);
            /* ADDED: ensures smooth transitions on border/color */
            will-change: background-color, transform;
        }

        /* Style for a drop zone when dragging over it */
        .drag-over {
            background-color: rgba(139, 92, 246, 0.3); /* Purple tint */
            transform: scale(1.05);
        }

        /* Style for a correctly placed slice */
        .correct {
            cursor: default;
            opacity: 1 !important;
            transform: scale(1) !important;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.8); /* Green glow */
            /* Force re-paint to ensure no leftover transforms */
            transition: none !important;
            transform: none !important;
        }

        /* Animation for incorrect drop */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .animate-shake {
            animation: shake 0.3s ease-in-out;
        }


        /* --- Celebration Animation --- */
        #celebration-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 100;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0;
            /* Use translate3d for hardware acceleration */
            animation: confetti-fall 5s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-10vh) translateX(0) rotate(0deg) translateZ(0);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) translateX(100px) rotate(720deg) translateZ(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="bg-gray-100">

<div id="screen-home" class="screen flex relative justify-center items-center">
    <span class="floating-emoji" style="top: 10%; left: 15%; animation-delay: 0s;">üçé</span>
    <span class="floating-emoji" style="top: 20%; left: 80%; animation-delay: -2s;">ü•≠</span>
    <span class="floating-emoji" style="top: 60%; left: 10%; animation-delay: -4s;">üíß</span>
    <span class="floating-emoji" style="top: 75%; left: 70%; animation-delay: -1s;">‚òÄÔ∏è</span>
    <span class="floating-emoji" style="top: 40%; left: 45%; animation-delay: -3s;">üß©</span>

    <div class="text-center z-10">
        <h1 class="text-7xl md:text-9xl font-bold text-white text-shadow-lg" style="text-shadow: 4px 4px 0 rgba(0,0,0,0.15);">
            WordSlice
        </h1>
        <p class="text-xl md:text-2xl text-white/90 mt-4 mb-12">Learn phonetics by playing puzzles!</p>
        <button id="home-play-btn" class="text-3xl font-bold text-purple-700 bg-white rounded-full px-12 py-5 shadow-xl transform transition-transform duration-200 hover:scale-110 active:scale-100">
            Play!
        </button>
    </div>
</div>

<div id="screen-levels" class="screen p-6 md:p-12" style="background-color: #f0f9ff;">
    <h2 class="text-4xl md:text-5xl font-bold text-center text-blue-800 mb-10">Choose a Word</h2>
    <div id="level-grid" class="max-w-5xl mx-auto grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-6 md:gap-8">
    </div>
</div>

<div id="screen-game" class="screen flex flex-col items-center justify-between p-4 md:p-8" style="background: linear-gradient(135deg, #dbeafe, #fce7f3);">

    <div class="w-full max-w-6xl flex justify-start">
        <button id="back-to-levels-btn" class="text-lg font-medium text-gray-700 bg-white rounded-lg px-5 py-2 shadow-md hover:bg-gray-100 transition-colors">
            &larr; Back to Levels
        </button>
    </div>

    <h2 class="text-4xl md:text-5xl font-bold text-center text-purple-700 my-4 md:my-0">
        Build the Word!
    </h2>

    <div id="full-word-display" class="hidden text-center my-6 flex flex-col items-center cursor-pointer group" role="button" tabindex="0">
        <h2 id="full-word-text" class="text-5xl md:text-7xl font-bold text-green-600 group-hover:text-green-500 transition-colors"></h2>
        <div id="full-word-speaker" class="mt-4 text-green-600 group-hover:text-green-500 transition-colors">
            <span class="text-5xl">üîä</span>
        </div>
    </div>

    <div id="placeholder-container" class="flex flex-row justify-center my-8 md:my-12">
    </div>

    <div id="slices-container" class="w-full max-w-4xl flex flex-row flex-wrap justify-center items-center gap-4 md:gap-6 p-6 bg-white/50 rounded-2xl shadow-inner min-h-[150px]">
    </div>

    <button id="reset-btn" class="text-xl font-semibold text-white bg-red-500 rounded-lg px-8 py-3 shadow-md hover:bg-red-600 transition-colors mt-8">
        Reset
    </button>

</div>

<div id="celebration-overlay"></div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- DATA ---
        const WORD_DATABASE = [
            {
                name: 'BANANA',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/banana.jpg',
                slices: [
                    { id: 0, wordPart: 'BA', phonetic: 'ba' },
                    { id: 1, wordPart: 'NA', phonetic: 'na' },
                    { id: 2, wordPart: 'NA', phonetic: 'na' }
                ]
            },
            {
                name: 'THANNI',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/thanni.jpg',
                slices: [
                    { id: 0, wordPart: 'THA', phonetic: 'tha' },
                    { id: 1, wordPart: 'NNI', phonetic: 'nee' }
                ]
            },
            {
                name: 'BUTTON',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/buton.jpg',
                slices: [
                    { id: 0, wordPart: 'BU', phonetic: 'ba' },
                    { id: 1, wordPart: 'TON', phonetic: 'ton' }
                ]
            },
            {
                name: 'FISH',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/fish.jpg',
                slices: [
                    { id: 0, wordPart: 'FI', phonetic: 'fih' },
                    { id: 1, wordPart: 'SH', phonetic: 'shh' }
                ]
            },
            {
                name: 'GIVE',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/giv.jpg',
                slices: [
                    { id: 0, wordPart: 'GI', phonetic: 'gih' },
                    { id: 1, wordPart: 'VE', phonetic: 'vuh' }
                ]
            },
            {
                name: 'JUICE',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/jooss.jpg',
                slices: [
                    { id: 0, wordPart: 'JOO', phonetic: 'joo' },
                    { id: 1, wordPart: 'SS', phonetic: 's' }
                ]
            },
            {
                name: 'KARAM',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/karam.jpg',
                slices: [
                    { id: 0, wordPart: 'KA', phonetic: 'kah' },
                    { id: 1, wordPart: 'RAM', phonetic: 'rum' }
                ]
            },
            {
                name: 'KASU',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/kasu.jpg',
                slices: [
                    { id: 0, wordPart: 'KA', phonetic: 'kah' },
                    { id: 1, wordPart: 'SU', phonetic: 'soo' }
                ]
            },
            {
                name: 'KOIYA',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/koiya.jpg',
                slices: [
                    { id: 0, wordPart: 'KOI', phonetic: 'koy' },
                    { id: 1, wordPart: 'YA', phonetic: 'yah' }
                ]
            },
            {
                name: 'KULI',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/kuli.jpg',
                slices: [
                    { id: 0, wordPart: 'KU', phonetic: 'koo' },
                    { id: 1, wordPart: 'LI', phonetic: 'lee' }
                ]
            },
            {
                name: 'LADOO',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/ladoo.jpg',
                slices: [
                    { id: 0, wordPart: 'LA', phonetic: 'lah' },
                    { id: 1, wordPart: 'DOO', phonetic: 'doo' }
                ]
            },
            {
                name: 'ODU',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/odu.jpg',
                slices: [
                    { id: 0, wordPart: 'O', phonetic: 'oh' },
                    { id: 1, wordPart: 'DU', phonetic: 'doo' }
                ]
            },
            {
                name: 'OPEN',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/open.jpg',
                slices: [
                    { id: 0, wordPart: 'O', phonetic: 'oh' },
                    { id: 1, wordPart: 'PEN', phonetic: 'pen' }
                ]
            },
            {
                name: 'PAPAYA',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/papaya.jpg',
                slices: [
                    { id: 0, wordPart: 'PA', phonetic: 'pa' },
                    { id: 1, wordPart: 'PA', phonetic: 'pa' },
                    { id: 2, wordPart: 'YA', phonetic: 'ya' }
                ]
            },
            {
                name: 'POTU',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/potu.jpg',
                slices: [
                    { id: 0, wordPart: 'PO', phonetic: 'poh' },
                    { id: 1, wordPart: 'TU', phonetic: 'too' }
                ]
            },
            {
                name: 'TSHIRT',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/tshirt.jpg',
                slices: [
                    { id: 0, wordPart: 'T', phonetic: 'tee' },
                    { id: 1, wordPart: 'SHIRT', phonetic: 'shirt' }
                ]
            },
            {
                name: 'YUMMY',
                image: 'https://raw.githubusercontent.com/maverick-premnath/word-slice-images/main/yummy.jpg',
                slices: [
                    { id: 0, wordPart: 'YUM', phonetic: 'yum' },
                    { id: 1, wordPart: 'MY', phonetic: 'mee' }
                ]
            }
        ];

        // Re-usable SVG for the speaker icon
        const SPEAKER_ICON_SVG = `
            <span class="text-3xl">üîä</span>
        `;

        // --- DOM Elements ---
        const screens = {
            home: document.getElementById('screen-home'),
            levels: document.getElementById('screen-levels'),
            game: document.getElementById('screen-game'),
        };
        const homePlayBtn = document.getElementById('home-play-btn');
        const levelGrid = document.getElementById('level-grid');
        const backToLevelsBtn = document.getElementById('back-to-levels-btn');
        const placeholderContainer = document.getElementById('placeholder-container');
        const slicesContainer = document.getElementById('slices-container');
        const fullWordDisplay = document.getElementById('full-word-display');
        const fullWordText = document.getElementById('full-word-text');
        const fullWordSpeaker = document.getElementById('full-word-speaker');
        const resetBtn = document.getElementById('reset-btn');
        const celebrationOverlay = document.getElementById('celebration-overlay');

        // --- State ---
        let currentWord = null; // Will hold the word object from WORD_DATABASE
        let correctSlices = []; // Array to track correct placements
        let draggingSlice = null; // The slice element being dragged

        // --- TOUCH DRAG STATE ---
        let initialOffsetX = 0;
        let initialOffsetY = 0;
        let currentDropZone = null;
        let sliceOriginalParent = null;

        // --- Functions (Unmodified) ---

        /**
         * Shows the specified screen and hides others
         * @param {string} screenId ('home', 'levels', or 'game')
         */
        function showScreen(screenId) {
            // Hide all screens
            for (const key in screens) {
                if (screens[key]) { // Check if element exists
                    screens[key].style.display = 'none';
                }
            }

            // Show the target screen
            if (screens[screenId]) {
                if (screenId === 'levels') {
                    screens[screenId].style.display = 'block';
                } else {
                    // home and game screens use flex
                    screens[screenId].style.display = 'flex';
                }
            } else {
                console.error(`Screen with id "${screenId}" not found.`);
            }
        }

        /**
         * Calculates the correct width and height classes for slices
         * Assumes the final image should be roughly square.
         * @param {number} numSlices - The number of slices (e.g., 2 or 3)
         */
        function getSliceDimensions(numSlices) {
            // Base Height: 160px (h-40) on mobile, 224px (h-56) on desktop
            const heightClasses = 'h-40 md:h-56';
            let widthClasses = '';

            switch (numSlices) {
                case 2:
                    // Width = 160/2 = 80px (w-20), 224/2 = 112px (w-28)
                    widthClasses = 'w-20 md:w-28';
                    break;
                case 3:
                    // Width = 160/3 = 53.3px (w-14 is 56px), 224/3 = 74.6px (w-20 is 80px)
                    // This is the closest approximation with Tailwind classes.
                    widthClasses = 'w-14 md:w-20';
                    break;
                case 4:
                    // Width = 160/4 = 40px (w-10), 224/4 = 56px (w-14)
                    widthClasses = 'w-10 md:w-14';
                    break;
                default: // 1 slice or fallback
                    // Width = 160px (w-40), 224px (w-56)
                    widthClasses = 'w-40 md:w-56';
            }
            return { heightClasses, widthClasses };
        }


        /**
         * Populates the level selection grid
         */
        function populateLevelGrid() {
            levelGrid.innerHTML = ''; // Clear existing grid
            WORD_DATABASE.forEach(word => {
                const card = document.createElement('button');
                // Added 'relative' class
                card.className = 'level-card aspect-square bg-white rounded-2xl shadow-lg flex justify-center items-center transform transition-transform duration-200 hover:scale-105 active:scale-95 overflow-hidden relative';
                card.dataset.wordName = word.name;
                // Added a div for the name overlay
                card.innerHTML = `
                    <img src="${word.image}" alt="${word.name}" class="w-full h-full object-cover">
                    <div class="absolute bottom-0 left-0 right-0 p-2 bg-black/50 text-center">
                        <span class="text-white font-bold text-lg uppercase">${word.name}</span>
                    </div>
                `;
                // FIX: Ensure 'word.name' is correctly captured in the closure for the click handler
                const wordName = word.name; // Capture word name explicitly
                card.addEventListener('click', () => {
                    startGame(wordName); // Use the captured word name
                });
                levelGrid.appendChild(card);
            });
        }

        /**
         * Sets up and starts the game for a specific word
         * @param {string} wordName - The name of the word (e.g., 'APPLE')
         */
        function startGame(wordName) {
            currentWord = WORD_DATABASE.find(w => w.name === wordName);
            if (!currentWord) {
                console.error(`Word "${wordName}" not found in database.`);
                return;
            }

            // Reset game state
            placeholderContainer.innerHTML = '';
            placeholderContainer.classList.add('gap-2');
            slicesContainer.innerHTML = '';
            fullWordDisplay.classList.add('hidden');
            fullWordText.textContent = '';
            correctSlices = new Array(currentWord.slices.length).fill(null);

            const numSlices = currentWord.slices.length;
            const { heightClasses, widthClasses } = getSliceDimensions(numSlices);

            // Create drop zones
            currentWord.slices.forEach((slice, index) => {
                const dropZone = document.createElement('div');
                // MODIFIED: Replaced fixed sizes with dynamic sizes
                dropZone.className = `drop-zone ${heightClasses} ${widthClasses} border-4 border-dashed border-gray-400 rounded-lg flex justify-center items-center text-gray-400 text-4xl font-bold`;
                dropZone.dataset.expectedId = slice.id;
                placeholderContainer.appendChild(dropZone);
            });

            // Create a shuffled version that is NEVER in correct order
            let shuffledSlices = [...currentWord.slices];

            // Keep shuffling until order differs from original
            do {
                shuffledSlices.sort(() => Math.random() - 0.5);
            } while (shuffledSlices.every((slice, i) => slice.id === currentWord.slices[i].id));


            shuffledSlices.forEach(slice => {
                const sliceEl = document.createElement('div');
                // MODIFIED: Replaced fixed sizes with dynamic sizes
                // IMPORTANT: Added 'relative' class is now in CSS to correctly position the speaker button
                sliceEl.className = `word-slice ${heightClasses} ${widthClasses} border-4 border-white rounded-lg shadow-lg cursor-grab`;
                sliceEl.draggable = true;
                sliceEl.dataset.id = slice.id;

                // Set the slice's background image
                sliceEl.style.backgroundImage = `url('${currentWord.image}')`;
                // CSS magic to show only a "slice" of the image
                sliceEl.style.backgroundSize = `${numSlices * 100}% 100%`;

                // CORRECTED: Calculate background position
                const position = (numSlices > 1) ? (slice.id / (numSlices - 1)) * 100 : 0;
                sliceEl.style.backgroundPosition = `${position}% 0`;

                // Create the word part and speaker button
                // IMPORTANT: Removed 'absolute bottom-2 flex items-center justify-center' inline classes
                // These are now handled by the CSS rule for .phonetic-speaker
                sliceEl.innerHTML = `
                    <div class="phonetic-speaker bg-white/80 rounded-full px-3 py-1 shadow-md cursor-pointer hover:bg-white transition-colors" data-phonetic="${slice.phonetic}">
                        <span class="text-xl font-bold text-gray-800 mr-2">${slice.wordPart}</span>
                        ${SPEAKER_ICON_SVG}
                    </div>
                `;
                slicesContainer.appendChild(sliceEl);
            });

            // Switch to game screen
            showScreen('game');
        }

        /**
         * Speaks the given text or phonetic sound
         * @param {string} text - The text to speak
         */
        function speak(text) {
            if (!window.speechSynthesis) {
                console.warn("Speech synthesis not supported in this browser.");
                return;
            }
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            utterance.rate = 0.9;
            utterance.pitch = 1.2;
            window.speechSynthesis.speak(utterance);
        }

        /**
         * Checks if all slices are in the correct place
         */
        function checkWinCondition() {
            if (correctSlices.every(slice => slice !== null)) {
                // All slices are correct!
                placeholderContainer.classList.remove('gap-2');
                fullWordText.textContent = currentWord.name;
                fullWordDisplay.classList.remove('hidden');
                slicesContainer.innerHTML = '<h3 class="text-2xl font-bold text-green-600">Well Done!</h3>';

                // Speak the full word
                setTimeout(() => speak(currentWord.name), 500);

                // Trigger celebration
                playCelebration();
            }
        }

        /**
         * Creates a confetti celebration effect
         */
        function playCelebration() {
            celebrationOverlay.innerHTML = ''; // Clear old confetti
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                confetti.style.height = `${Math.random() * 10 + 5}px`;
                confetti.style.width = `${Math.random() * 10 + 5}px`;
                confetti.style.transform = `rotate(${Math.random() * 360}deg) translateZ(0)`; // Added translateZ(0) for acceleration
                celebrationOverlay.appendChild(confetti);
            }

            // Clear confetti after animation ends
            setTimeout(() => {
                celebrationOverlay.innerHTML = '';
            }, 5000);
        }

        // --- Event Listeners ---

        // Screen Switching
        homePlayBtn.addEventListener('click', () => {
            populateLevelGrid();
            showScreen('levels');
        });

        backToLevelsBtn.addEventListener('click', () => {
            showScreen('levels');
        });

        // Reset Button
        resetBtn.addEventListener('click', () => {
            if (currentWord) {
                startGame(currentWord.name); // Restart current level
            }
        });

        // Full Word Speaker
        fullWordDisplay.addEventListener('click', () => {
            if (currentWord) {
                speak(currentWord.name);
            }
        });

        // Phonetic Speaker (uses event delegation)
        document.body.addEventListener('click', (e) => {
            const speakerBtn = e.target.closest('.phonetic-speaker');
            if (speakerBtn) {
                const phonetic = speakerBtn.dataset.phonetic;
                if (phonetic) {
                    speak(phonetic);
                    // Prevent the click event from bubbling up and possibly starting a drag if this was a touch
                    e.stopPropagation();
                }
            }
        });

        // --- Drag and Drop Logic (Desktop/Mouse - Unmodified) ---

        // For Draggable Slices
        document.body.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('word-slice')) {
                // Check if a correct slice is being dragged (shouldn't happen, but good check)
                if (e.target.classList.contains('correct')) {
                    e.preventDefault();
                    return;
                }
                draggingSlice = e.target;
                // Set data for Firefox/IE compatibility (not strictly necessary for the logic, but good practice)
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
                // Use setTimeout to ensure the 'dragging' class is applied *after* dragstart handles the image/data
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        document.body.addEventListener('dragend', (e) => {
            if (draggingSlice) {
                draggingSlice.classList.remove('dragging');
                draggingSlice = null;
            }
        });

        // For Drop Zones
        placeholderContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // Necessary to allow dropping
            const dropZone = e.target.closest('.drop-zone');
            if (dropZone && !dropZone.classList.contains('correct') && !dropZone.querySelector('.word-slice')) {
                dropZone.classList.add('drag-over');
            }
        });

        placeholderContainer.addEventListener('dragleave', (e) => {
            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) {
                dropZone.classList.remove('drag-over');
            }
        });

        placeholderContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const dropZone = e.target.closest('.drop-zone');

            // Only allow drop if there's a drop zone, a slice is being dragged, and the zone is empty
            if (!dropZone || !draggingSlice || dropZone.querySelector('.word-slice')) {
                if (dropZone) dropZone.classList.remove('drag-over');
                return;
            }

            dropZone.classList.remove('drag-over');
            const sliceId = draggingSlice.dataset.id;
            const expectedId = dropZone.dataset.expectedId;

            if (sliceId === expectedId) {
                // --- CORRECT DROP ---
                dropZone.innerHTML = '';

                // Remove borders to "merge" them (as per your original intention)
                dropZone.classList.remove('border-dashed', 'border-gray-400', 'rounded-lg');
                draggingSlice.classList.remove('border-4', 'border-white', 'shadow-lg', 'rounded-lg');

                dropZone.appendChild(draggingSlice);
                // The correct class uses 'transition: none !important' to kill the transform
                draggingSlice.classList.add('correct');
                draggingSlice.classList.remove('cursor-grab');
                draggingSlice.draggable = false;

                correctSlices[parseInt(sliceId)] = draggingSlice;

                const phonetic = draggingSlice.querySelector('.phonetic-speaker')?.dataset.phonetic;
                if (phonetic) {
                    speak(phonetic);
                }

                checkWinCondition();

            } else {
                // --- INCORRECT DROP ---
                dropZone.classList.add('animate-shake');
                setTimeout(() => dropZone.classList.remove('animate-shake'), 500);
            }
        });

        // ------------------------------------------------------------------
        // --- Touch Drag and Drop (Mobile Support) - Unmodified Fix ---
        // ------------------------------------------------------------------

        document.body.addEventListener('touchstart', (e) => {
            // Ignore multi-touch (e.g., pinch-to-zoom)
            if (e.touches.length > 1) return;

            const touchSlice = e.target.closest('.word-slice');

            // Prevent drag if the click target is the speaker button
            if (e.target.closest('.phonetic-speaker') || touchSlice?.classList.contains('correct')) {
                 draggingSlice = null; // Important reset
                 return;
            }

            if (touchSlice) {
                e.preventDefault(); // Prevent screen scrolling on drag start

                draggingSlice = touchSlice;
                sliceOriginalParent = draggingSlice.parentElement; // Store where it came from

                // Calculate the offset from the touch point to the slice's top-left corner
                const rect = draggingSlice.getBoundingClientRect();
                initialOffsetX = e.touches[0].clientX - rect.left;
                initialOffsetY = e.touches[0].clientY - rect.top;

                // CRITICAL FIX: Apply fixed position and drag style immediately
                draggingSlice.classList.add('touch-dragging', 'dragging');

                // Set the initial transform based on the current touch position
                const currentX = e.touches[0].clientX - initialOffsetX;
                const currentY = e.touches[0].clientY - initialOffsetY;

                draggingSlice.style.transform = `translate3d(${currentX}px, ${currentY}px, 0) scale(1.1)`;
            }
        }, { passive: false });

        document.body.addEventListener('touchmove', (e) => {
            if (!draggingSlice) return;
            e.preventDefault(); // Prevent screen scrolling

            // Move the slice using translate3d for hardware acceleration
            const currentX = e.touches[0].clientX - initialOffsetX;
            const currentY = e.touches[0].clientY - initialOffsetY;

            draggingSlice.style.transform = `translate3d(${currentX}px, ${currentY}px, 0) scale(1.1)`;

            // Find the element underneath the center of the touch
            let elementAtPoint = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
            let dropZone = elementAtPoint ? elementAtPoint.closest('.drop-zone') : null;

            // Handle drag-over visual feedback
            if (currentDropZone && currentDropZone !== dropZone) {
                currentDropZone.classList.remove('drag-over');
                currentDropZone = null;
            }

            if (dropZone && !dropZone.classList.contains('correct') && !dropZone.querySelector('.word-slice')) {
                dropZone.classList.add('drag-over');
                currentDropZone = dropZone;
            }

        }, { passive: false });

        document.body.addEventListener('touchend', (e) => {
            if (!draggingSlice) return;

            // Clean up temporary classes
            draggingSlice.classList.remove('dragging', 'touch-dragging');

            if (currentDropZone) {
                // --- Attempting a drop ---
                currentDropZone.classList.remove('drag-over');
                const sliceId = draggingSlice.dataset.id;
                const expectedId = currentDropZone.dataset.expectedId;

                if (sliceId === expectedId && !currentDropZone.querySelector('.word-slice')) {
                    // --- CORRECT DROP (TOUCH) ---
                    currentDropZone.innerHTML = '';

                    // CRITICAL FIX: Clear styles before appending to remove inline fixed positioning/transform
                    draggingSlice.style.transform = '';
                    draggingSlice.style.position = '';
                    currentDropZone.appendChild(draggingSlice);

                    // Remove borders to "merge" them (as per your original intention)
                    currentDropZone.classList.remove('border-dashed', 'border-gray-400', 'rounded-lg');
                    draggingSlice.classList.remove('border-4', 'border-white', 'shadow-lg', 'rounded-lg');

                    // Apply the 'correct' class to remove all transformation styles
                    draggingSlice.classList.add('correct');
                    draggingSlice.classList.remove('cursor-grab');
                    draggingSlice.draggable = false;

                    correctSlices[parseInt(sliceId)] = draggingSlice;

                    const phonetic = draggingSlice.querySelector('.phonetic-speaker')?.dataset.phonetic;
                    if (phonetic) {
                        speak(phonetic);
                    }

                    checkWinCondition();
                } else {
                    // --- INCORRECT DROP (TOUCH) ---
                    // CRITICAL FIX: Clear styles before appending back to original container
                    draggingSlice.style.transform = '';
                    draggingSlice.style.position = '';
                    sliceOriginalParent.appendChild(draggingSlice);

                    // Optional: shake the incorrect drop zone
                    currentDropZone.classList.add('animate-shake');
                    setTimeout(() => currentDropZone.classList.remove('animate-shake'), 500);
                }
            } else {
                // --- No drop zone found (return to original) ---
                // CRITICAL FIX: Clear styles before appending back to original container
                draggingSlice.style.transform = '';
                draggingSlice.style.position = '';
                sliceOriginalParent.appendChild(draggingSlice);
            }

            // Final state reset
            draggingSlice = null;
            currentDropZone = null;
            sliceOriginalParent = null;
        });


        // --- Initial Setup ---
        showScreen('home'); // Show the home screen first

    });
</script>
</body>
</html>